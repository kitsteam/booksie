#!/usr/bin/env node
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const {
  assert,
  cachePath,
  copyDirectory,
  copyFile,
  distributionPath,
  executeCommand,
  executeCurl,
  fetchURL,
  makeDirectories,
  memoize,
  symlinkFile,
} = require('.');

const coverSize = 192;
const spriteSize = 100;

const sourceNames = {
  'book-dash': 'Book Dash',
  'paul-choy': 'Paul Choy',
  'pratham-books': 'Pratham Books',
  'room-to-read': 'Room to Read',
  'storybooks-canada': 'Storybooks Canada',
  bookbot: 'Bookbot',
  icharacter: 'iCharacter',
  rubbishbooks: 'Rubbish Books',
  storyweaver: 'StoryWeaver',
};

const buildCovers = (scale = 1) => {
  const output = distributionPath(
    'covers',
    `%d${scale === 1 ? '' : `@${scale}x`}.jpg`
  );
  scale === 1 || process.env.CI
    ? (fs.existsSync(output.replace('%d', '0')) && !process.env.CI) ||
      executeCommand(
        [
          'montage',
          ...downloadCovers(),
          '-geometry',
          `${coverSize * scale}x${coverSize * scale}`,
          '-interlace',
          'Plane',
          '-quality',
          '80%',
          '-tile',
          `1x${spriteSize}`,
          makeDirectories(output),
        ],
        { env: { MAGICK_TEMPORARY_PATH: cachePath() } }
      )
    : fs
        .readdirSync(path.dirname(output), { withFileTypes: true })
        .filter(dirent => dirent.isFile())
        .forEach(dirent =>
          symlinkFile(
            dirent.name,
            output.replace('%d', path.basename(dirent.name, '.jpg'))
          )
        );
  const regExp = new RegExp(
    path
      .basename(output)
      .replace('%d', '\\d+')
      .replace('.', '\\.')
  );
  return fs
    .readdirSync(path.dirname(output))
    .filter(filename => regExp.test(filename))
    .map(filename => path.join(path.dirname(output), filename));
};

const buildIndex = () =>
  fs.writeFileSync(
    makeDirectories(distributionPath('index.html')),
    generateIndex()
  );

const cache = func => (...args) => {
  const cache = cachePath(
    `${func.name}:${crypto
      .createHash('md5')
      .update(JSON.stringify(args))
      .digest('hex')}`
  );
  fs.existsSync(cache) ||
    fs.writeFileSync(makeDirectories(cache), JSON.stringify(func(...args)));
  return JSON.parse(fs.readFileSync(cache, 'utf8'));
};

const copyImages = () => {
  const target = distributionPath('images');
  process.env.CI
    ? copyDirectory('images', target)
    : symlinkFile('../images', target);
};

const copyScripts = () =>
  ['pdf.min.js', 'pdf.worker.min.js'].forEach(filename =>
    copyFile(
      path.join('node_modules/pdfjs-dist/build', filename),
      distributionPath('scripts', filename)
    )
  );

const downloadCovers = () => {
  const books = fetchBooks().map(book => ({
    ...book,
    cover: cachePath(book.source, `${book.slug}.jpg`),
  }));
  const options = books.reduce(
    (options, book) =>
      fs.existsSync(book.cover)
        ? options
        : [
            ...options,
            '-o',
            makeDirectories(book.cover),
            `https://data.booksie.org/${encodeURIComponent(
              book.source
            )}/${encodeURIComponent(book.slug)}.jpg`,
          ],
    []
  );
  options.length && executeCurl(options);
  return books.map(book => book.cover);
};

const fetchBooks = () =>
  JSON.parse(
    (process.env.CI ? memoize : cache)(fetchURL)(
      'https://data.booksie.org/books.json'
    )
  ).sort((a, b) => -a.created.localeCompare(b.created));

const generateBook = book =>
  readInclude('book', {
    ...book,
    sourceName: assert(
      sourceNames[book.source],
      `Unknow source ${book.source}`
    ),
  });

const generateBooks = () =>
  fetchBooks()
    .map((book, index) => ({
      ...book,
      offset: (index % spriteSize) * coverSize,
      sprite: Math.floor(index / spriteSize),
    }))
    .map(book => generateBook(book).trim())
    .join('');

const generateCoversStyle = () =>
  Array.from(Array(Math.ceil(fetchBooks().length / spriteSize)))
    .map((value, index) =>
      `
.cover-${index} {
  background-image: url(covers/${index}.jpg);
  background-image: -webkit-image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
  background-image: image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
}
`.trim()
    )
    .join('\n');

const generateFooter = () =>
  readInclude('footer', {
    script: process.env.CI ? generateInlineScript() : generateScripts(),
    year: new Date().getFullYear(),
  }).trim();

const generateHead = () =>
  readInclude('head', {
    coverSize,
    coversStyle: generateCoversStyle(),
    description:
      'Booksie: an open catalog of free picture storybooks for children instantly available for reading.',
    name: 'Booksie',
    style: process.env.CI ? generateStyle() : generateStylesheets(),
    title: 'Free Picture Storybooks for Children',
    url: `https://${fs
      .readFileSync('.travis.yml', 'utf8')
      .match(/(?<= fqdn: ).+/)}/`,
  }).replace('</html>\n', '');

const generateHeader = () => readInclude('header');

const generateIndex = () =>
  generateHead() + generateHeader() + generateMain() + generateFooter();

const generateMain = () =>
  readInclude('main', {
    books: generateBooks(),
    viewer: readInclude('viewer'),
  });

const generateInlineScript = () => `<script>
${fs
  .readdirSync(scriptPath())
  .map(filename => fs.readFileSync(scriptPath(filename), 'utf8').trim())
  .join('\n\n')}
</script>`;

const generateScripts = () =>
  fs
    .readdirSync(scriptPath())
    .map(filename => {
      symlinkFile(
        path.join('..', scriptPath(filename)),
        distributionPath(filename)
      );
      return `<script src="${filename}"></script>`;
    })
    .join('\n');

const generateStyle = () =>
  `<style>
${fs
  .readdirSync(stylePath())
  .map(filename => fs.readFileSync(stylePath(filename), 'utf8').trim())
  .join('\n\n')}
</style>`;

const generateStylesheets = () =>
  fs
    .readdirSync(stylePath())
    .map(filename => {
      symlinkFile(
        path.join('..', stylePath(filename)),
        distributionPath(filename)
      );
      return `<link href="${filename}" rel="stylesheet">`;
    })
    .join('\n');

const includePath = (...components) => path.join('includes', ...components);

const main = () => {
  buildCovers();
  buildCovers(2);
  buildIndex();
  copyImages();
  copyScripts();
};

const readInclude = (name, replacements = {}) =>
  replaceTokens(
    fs.readFileSync(includePath(`${name}.html`), 'utf8'),
    replacements
  );

const replaceTokens = (string, replacements) =>
  Object.entries(replacements).reduce(
    (string, [token, replacement]) =>
      string
        .replace(new RegExp(`^ +(?=\\{${token}})`, 'gm'), '')
        .replace(new RegExp(`\\{${token}}`, 'g'), replacement),
    string
  );

const scriptPath = (...components) => path.join('scripts', ...components);

const stylePath = (...components) => path.join('styles', ...components);

require.main === module && main();
