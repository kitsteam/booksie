#!/usr/bin/env node
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { execFileSync } = require('child_process');
const {
  cachePath,
  distributionPath,
  executeCurl,
  fetchURL,
  log,
  makeDirectories,
  memoize,
} = require('.');

const coverSize = 256;
const spriteSize = 100;

const buildCovers = (scale = 1) => {
  const output = distributionPath(
    'covers',
    `%d${scale === 1 ? '' : `@${scale}x`}.jpg`
  );
  if (!fs.existsSync(output.replace('%d', '0')) || process.env.CI) {
    log(`Building ${scale}x covers`, () =>
      execFileSync(
        'montage',
        [
          ...downloadCovers(),
          '-geometry',
          `${coverSize * scale}x${coverSize * scale}`,
          '-interlace',
          'Plane',
          '-quality',
          '80%',
          '-tile',
          `1x${spriteSize}`,
          makeDirectories(output),
        ],
        { env: { MAGICK_TEMPORARY_PATH: cachePath() } }
      )
    );
  }
  return fs
    .readdirSync(path.dirname(output))
    .filter(filename =>
      filename.endsWith(path.basename(output).replace('%d', ''))
    )
    .map(filename => path.join(path.dirname(output), filename));
};

const buildIndex = () =>
  log('Building index', () =>
    fs.writeFileSync(
      makeDirectories(distributionPath('index.html')),
      generateIndex()
    )
  );

const cache = func => (...args) => {
  const cache = cachePath(
    `${func.name}:${crypto
      .createHash('md5')
      .update(JSON.stringify(args))
      .digest('hex')}`
  );
  fs.existsSync(cache) ||
    fs.writeFileSync(makeDirectories(cache), JSON.stringify(func(...args)));
  return JSON.parse(fs.readFileSync(cache, 'utf8'));
};

const generateCoversStyle = () =>
  Array.from(Array(Math.ceil(fetchBooks().length / spriteSize)))
    .map((value, index) =>
      `
.cover-${index} {
  background-image: url(covers/${index}.jpg);
  background-image: -webkit-image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
  background-image: image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
}
`.trim()
    )
    .join('\n');

const downloadCovers = () => {
  const books = fetchBooks().map(book => ({
    ...book,
    cover: cachePath(path.join(book.source, `${book.slug}.jpg`)),
  }));
  const options = books.reduce(
    (options, book) =>
      fs.existsSync(book.cover)
        ? options
        : [
            ...options,
            '-o',
            makeDirectories(book.cover),
            `https://data.booksie.org/${encodeURIComponent(
              book.source
            )}/${encodeURIComponent(book.slug)}.jpg`,
          ],
    []
  );
  options.length && executeCurl(options);
  return books.map(book => book.cover);
};

const fetchBooks = () =>
  JSON.parse(
    (process.env.CI ? memoize : cache)(fetchURL)(
      'https://data.booksie.org/books.json'
    )
  ).sort((a, b) => -a.created.localeCompare(b.created));

const generateBook = book => replaceTokens(readInclude('book'), book);

const generateBooks = () =>
  fetchBooks()
    .map((book, index) => ({
      ...book,
      offset: (index % spriteSize) * coverSize,
      sprite: Math.floor(index / spriteSize),
    }))
    .map(book => generateBook(book).trim())
    .join('');

const generateIndex = () =>
  replaceTokens(readInclude('header'), {
    coverSize,
    coversStyle: generateCoversStyle(),
  }) +
  generateStyles() +
  generateBooks() +
  readInclude('footer');

const generateStyles = () =>
  (process.env.CI ? '<style>\n' : '') +
  fs
    .readdirSync('styles')
    .map(filename => {
      const stylesheet = path.join('styles', filename);
      if (process.env.CI) {
        return fs.readFileSync(stylesheet, 'utf8');
      } else {
        const symlink = distributionPath(filename);
        fs.existsSync(symlink) ||
          fs.symlinkSync(path.join('..', stylesheet), symlink);
        return `<link href="${filename}" rel="stylesheet">`;
      }
    })
    .join('\n') +
  (process.env.CI ? '</style>' : '') +
  '\n';

const main = () => {
  buildCovers();
  buildCovers(2);
  buildIndex();
};

const readInclude = name =>
  fs.readFileSync(path.join('includes', `${name}.html`), 'utf8');

const replaceTokens = (string, replacements) =>
  Object.entries(replacements).reduce(
    (string, [token, replacement]) =>
      string.replace(new RegExp(`\\{${token}}`, 'g'), replacement),
    string
  );

require.main === module && main();
