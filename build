#!/usr/bin/env node
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { execFileSync } = require('child_process');
const {
  cachePath,
  distributionPath,
  fetchURL,
  makeDirectories,
  memoize,
} = require('.');

const coverSize = 256;
const spriteSize = 100;

const buildCovers = () => {
  const output = distributionPath('covers.jpg');
  if (!fs.existsSync(output) || process.env.CI) {
    execFileSync('montage', [
      ...fetchBooks().map(book => {
        const output = cachePath(path.join(book.source, `${book.slug}.jpg`));
        if (!fs.existsSync(output)) {
          execFileSync(
            'convert',
            [
              '-resize',
              `${coverSize}x${coverSize}>`,
              '-',
              makeDirectories(output),
            ],
            {
              input: fetchURL(
                `https://data.booksie.org/${encodeURIComponent(
                  book.source
                )}/${encodeURIComponent(book.slug)}.jpg`,
                undefined,
                true
              ),
            }
          );
        }
        return output;
      }),
      '-quality',
      '80%',
      '-tile',
      `${spriteSize}x`,
      '-geometry',
      `${coverSize}x${coverSize}`,
      makeDirectories(output),
    ]);
  }
  return output;
};

const buildIndex = () =>
  fs.writeFileSync(
    makeDirectories(distributionPath('index.html')),
    generateIndex()
  );

const cache = func => (...args) => {
  const cache = cachePath(
    `${func.name}:${crypto
      .createHash('md5')
      .update(JSON.stringify(args))
      .digest('hex')}`
  );
  fs.existsSync(cache) ||
    fs.writeFileSync(makeDirectories(cache), JSON.stringify(func(...args)));
  return JSON.parse(fs.readFileSync(cache, 'utf8'));
};

const fetchBooks = () =>
  JSON.parse(
    (process.env.CI ? memoize : cache)(fetchURL)(
      'https://data.booksie.org/books.json'
    )
  ).sort((a, b) => -a.created.localeCompare(b.created));

const generateBook = book => replaceTokens(readInclude('book'), book);

const generateBooks = () =>
  fetchBooks()
    .map((book, index) => ({
      ...book,
      left: (index % spriteSize) * coverSize,
      top: Math.floor(index / spriteSize) * coverSize,
    }))
    .map(book => generateBook(book).trim())
    .join('');

const generateIndex = () =>
  replaceTokens(readInclude('header'), { coverSize }) +
  generateStyles() +
  generateBooks() +
  readInclude('footer');

const generateStyles = () =>
  (process.env.CI ? '<style>\n' : '') +
  fs
    .readdirSync('styles')
    .map(filename => {
      const stylesheet = path.join('styles', filename);
      if (process.env.CI) {
        return fs.readFileSync(stylesheet, 'utf8');
      } else {
        const symlink = distributionPath(filename);
        fs.existsSync(symlink) ||
          fs.symlinkSync(path.join('..', stylesheet), symlink);
        return `<link href="${filename}" rel="stylesheet">`;
      }
    })
    .join('\n') +
  (process.env.CI ? '</style>' : '') +
  '\n';

const main = () => {
  buildCovers();
  buildIndex();
};

const readInclude = name =>
  fs.readFileSync(path.join('includes', `${name}.html`), 'utf8');

const replaceTokens = (string, replacements) =>
  Object.entries(replacements).reduce(
    (string, [token, replacement]) =>
      string.replace(new RegExp(`\\{${token}}`, 'g'), replacement),
    string
  );

require.main === module && main();
