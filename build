#!/usr/bin/env node
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const rollup = require('rollup');
const {
  assert,
  cachePath,
  copyDirectory,
  copyFile,
  distributionPath,
  executeCommand,
  executeCurl,
  fetchURL,
  makeDirectories,
  memoize,
  symlinkFile,
} = require('.');

const coverSize = 192;
const spriteSize = 100;

const sourceNames = {
  'book-dash': 'Book Dash',
  'paul-choy': 'Paul Choy',
  'pratham-books': 'Pratham Books',
  'room-to-read': 'Room to Read',
  'storybooks-canada': 'Storybooks Canada',
  bookbot: 'Bookbot',
  icharacter: 'iCharacter',
  rubbishbooks: 'Rubbish Books',
  storyweaver: 'StoryWeaver',
};

const buildCovers = (scale = 1) => {
  const covers = distributionPath('covers');
  const outputMask = path.join(
    covers,
    `%d${scale === 1 ? '' : `@${scale}x`}.jpg`
  );
  scale === 1 || process.env.CI
    ? (fs.existsSync(outputMask.replace('%d', '0')) && !process.env.CI) ||
      executeCommand(
        [
          'montage',
          ...downloadCovers(),
          '-geometry',
          `${coverSize * scale}x${coverSize * scale}`,
          '-interlace',
          'Plane',
          '-quality',
          '80%',
          '-tile',
          `1x${spriteSize}`,
          makeDirectories(outputMask),
        ],
        { env: { MAGICK_TEMPORARY_PATH: cachePath() } }
      )
    : fs
        .readdirSync(covers)
        .filter(filename => !/@\d+x\.jpg$/.test(filename))
        .forEach(filename => {
          const output = outputMask.replace(
            '%d',
            path.basename(filename, '.jpg')
          );
          fs.existsSync(output) ||
            executeCommand([
              'convert',
              '-resize',
              `${scale * 100}%`,
              path.join(covers, filename),
              output,
            ]);
        });
  return fs
    .readdirSync(covers)
    .filter(filename =>
      new RegExp(
        path
          .basename(outputMask)
          .replace('%d', '\\d+')
          .replace('.', '\\.')
      ).test(filename)
    )
    .map(filename => path.join(covers, filename));
};

const buildIndex = () =>
  fs.writeFileSync(
    makeDirectories(distributionPath('index.html')),
    generateIndex()
  );

const cache = func => (...args) => {
  const cache = cachePath(
    `${func.name}:${crypto
      .createHash('md5')
      .update(JSON.stringify(args))
      .digest('hex')}`
  );
  fs.existsSync(cache) ||
    fs.writeFileSync(makeDirectories(cache), JSON.stringify(func(...args)));
  return JSON.parse(fs.readFileSync(cache, 'utf8'));
};

const copyImages = () => {
  const target = distributionPath('images');
  process.env.CI
    ? copyDirectory('images', target)
    : symlinkFile('../images', target);
};

const copyPDFJSFiles = () =>
  ['pdf.min.js', 'pdf.worker.min.js'].forEach(filename =>
    copyFile(
      path.join('node_modules/pdfjs-dist/build', filename),
      distributionPath('pdfjs', filename)
    )
  );

const downloadCovers = () => {
  const books = fetchBooks().map(book => ({
    ...book,
    cover: cachePath(book.source, `${book.slug}.jpg`),
  }));
  const options = books.reduce(
    (options, book) =>
      fs.existsSync(book.cover)
        ? options
        : [
            ...options,
            '-o',
            makeDirectories(book.cover),
            `https://data.booksie.org/${encodeURIComponent(
              book.source
            )}/${encodeURIComponent(book.slug)}.jpg`,
          ],
    []
  );
  options.length && executeCurl(options);
  return books.map(book => book.cover);
};

const fetchBooks = () =>
  JSON.parse(
    (process.env.CI ? memoize : cache)(fetchURL)(
      'https://data.booksie.org/books.json'
    )
  ).sort((a, b) => -a.added.localeCompare(b.added));

const generateBook = book =>
  readInclude('book', {
    ...book,
    sourceName: assert(
      sourceNames[book.source],
      `Unknow source ${book.source}`
    ),
  });

const generateBooks = source => {
  const books = fetchBooks();
  let startIndex;
  return books
    .filter(book => book.source === source)
    .map((book, index) => {
      startIndex === undefined &&
        (startIndex = books.findIndex(
          foundBook =>
            foundBook.source === source && foundBook.slug === book.slug
        ));
      return {
        ...book,
        offset: ((startIndex + index) % spriteSize) * 100,
        sprite: Math.floor((startIndex + index) / spriteSize),
      };
    })
    .map(book => generateBook(book).trim())
    .join('');
};

const generateCoversStyle = () =>
  Array.from(Array(Math.ceil(fetchBooks().length / spriteSize)))
    .map((value, index) =>
      `
.cover-${index} {
  background-image: url(covers/${index}.jpg);
  background-image: -webkit-image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
  background-image: image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
}
`.trim()
    )
    .join('\n');

const generateDevelopmentScript = () => {
  ['node_modules', 'scripts'].forEach(filename =>
    symlinkFile(path.join('..', filename), distributionPath(filename))
  );
  return `<script src="scripts/index.js" type="module"></script>`;
};

const generateDevelopmentStyle = () =>
  fs
    .readdirSync('styles')
    .map(filename => {
      symlinkFile(path.join('../styles', filename), distributionPath(filename));
      return `<link href="${filename}" rel="stylesheet">`;
    })
    .join('\n');

const generateFooter = () =>
  readInclude('footer', { year: new Date().getFullYear() }).trim();

const generateHead = () =>
  readInclude('head', {
    coverSize,
    coversStyle: generateCoversStyle(),
    description:
      'Booksie: an open catalog of free picture storybooks for children instantly available for reading.',
    name: 'Booksie',
    script: process.env.CI
      ? generateProductionScript()
      : generateDevelopmentScript(),
    style: process.env.CI
      ? generateProductionStyle()
      : generateDevelopmentStyle(),
    title: 'Free Picture Storybooks for Children',
    url: `https://${fs
      .readFileSync('.travis.yml', 'utf8')
      .match(/(?<= fqdn: ).+/)}/`,
  }).replace('</html>\n', '');

const generateHeader = () => readInclude('header');

const generateIndex = () =>
  generateHead() + generateHeader() + generateMain() + generateFooter();

const generateMain = () =>
  readInclude('main', {
    books: generateSourceBooks(),
    sources: generateSources(),
    viewer: readInclude('viewer'),
  });

const generateProductionScript = () => `<script>
${executeCommand([
  'rollup',
  'scripts/index.js',
  '-f',
  'iife',
  '--silent',
]).trim()}
</script>`;

const generateProductionStyle = () =>
  `<style>
${fs
  .readdirSync('styles')
  .map(filename =>
    fs.readFileSync(path.join('styles', filename), 'utf8').trim()
  )
  .join('\n\n')}
</style>`;

const generateSourceBooks = () =>
  Object.keys(sourceNames)
    .sort()
    .map(source =>
      readInclude('source-books', {
        books: generateBooks(source),
        source,
        sourceName: sourceNames[source],
      })
    )
    .join('\n');

const generateSources = () =>
  readInclude('sources', {
    links: Object.keys(sourceNames)
      .sort()
      .map(source => `<a href="#${source}">${sourceNames[source]}</a>`)
      .join(', '),
  });

const main = () => {
  buildCovers();
  buildCovers(2);
  buildIndex();
  copyImages();
  copyPDFJSFiles();
};

const readInclude = (name, replacements = {}) =>
  replaceTokens(
    fs.readFileSync(path.join('includes', `${name}.html`), 'utf8'),
    replacements
  );

const replaceTokens = (string, replacements) =>
  Object.entries(replacements).reduce(
    (string, [token, replacement]) =>
      string
        .replace(new RegExp(`^ +(?=<!--${token}-->)`, 'gm'), '')
        .replace(new RegExp(`<!--${token}-->`, 'g'), replacement),
    string
  );

require.main === module && main();
