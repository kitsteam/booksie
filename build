#!/usr/bin/env node
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const {
  cachePath,
  distributionPath,
  executeCommand,
  executeCurl,
  fetchURL,
  makeDirectories,
  memoize,
} = require('.');

const coverSize = 256;
const spriteSize = 100;

const buildCovers = (scale = 1) => {
  const output = distributionPath(
    'covers',
    `%d${scale === 1 ? '' : `@${scale}x`}.jpg`
  );
  (fs.existsSync(output.replace('%d', '0')) && !process.env.CI) ||
    executeCommand(
      [
        'montage',
        ...downloadCovers(),
        '-geometry',
        `${coverSize * scale}x${coverSize * scale}`,
        '-interlace',
        'Plane',
        '-quality',
        '80%',
        '-tile',
        `1x${spriteSize}`,
        makeDirectories(output),
      ],
      { env: { MAGICK_TEMPORARY_PATH: cachePath() } }
    );
  return fs
    .readdirSync(path.dirname(output))
    .filter(filename =>
      filename.endsWith(path.basename(output).replace('%d', ''))
    )
    .map(filename => path.join(path.dirname(output), filename));
};

const buildIndex = () =>
  fs.writeFileSync(
    makeDirectories(distributionPath('index.html')),
    generateIndex()
  );

const cache = func => (...args) => {
  const cache = cachePath(
    `${func.name}:${crypto
      .createHash('md5')
      .update(JSON.stringify(args))
      .digest('hex')}`
  );
  fs.existsSync(cache) ||
    fs.writeFileSync(makeDirectories(cache), JSON.stringify(func(...args)));
  return JSON.parse(fs.readFileSync(cache, 'utf8'));
};

const generateCoversStyle = () =>
  Array.from(Array(Math.ceil(fetchBooks().length / spriteSize)))
    .map((value, index) =>
      `
.cover-${index} {
  background-image: url(covers/${index}.jpg);
  background-image: -webkit-image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
  background-image: image-set(
    url(covers/${index}.jpg) 1x,
    url(covers/${index}@2x.jpg) 2x
  );
}
`.trim()
    )
    .join('\n');

const downloadCovers = () => {
  const books = fetchBooks().map(book => ({
    ...book,
    cover: cachePath(path.join(book.source, `${book.slug}.jpg`)),
  }));
  const options = books.reduce(
    (options, book) =>
      fs.existsSync(book.cover)
        ? options
        : [
            ...options,
            '-o',
            makeDirectories(book.cover),
            `https://data.booksie.org/${encodeURIComponent(
              book.source
            )}/${encodeURIComponent(book.slug)}.jpg`,
          ],
    []
  );
  options.length && executeCurl(options);
  return books.map(book => book.cover);
};

const fetchBooks = () =>
  JSON.parse(
    (process.env.CI ? memoize : cache)(fetchURL)(
      'https://data.booksie.org/books.json'
    )
  ).sort((a, b) => -a.created.localeCompare(b.created));

const generateBook = book => replaceTokens(readInclude('book'), book);

const generateBooks = () =>
  fetchBooks()
    .map((book, index) => ({
      ...book,
      offset: (index % spriteSize) * coverSize,
      sprite: Math.floor(index / spriteSize),
    }))
    .map(book => generateBook(book).trim())
    .join('');

const generateFooter = () => readInclude('footer');

const generateHead = () =>
  replaceTokens(readInclude('head'), {
    coverSize,
    coversStyle: generateCoversStyle(),
    style: process.env.CI ? generateStyle() : generateStylesheets(),
  });

const generateHeader = () => readInclude('header');

const generateIndex = () =>
  generateHead() + generateHeader() + generateMain() + generateFooter();

const generateMain = () =>
  replaceTokens(readInclude('main'), {
    books: generateBooks(),
  });

const generateStyle = () =>
  `<style>
${fs
  .readdirSync('styles')
  .map(filename =>
    fs.readFileSync(path.join('styles', filename), 'utf8').trim()
  )
  .join('\n\n')}
</style>`;

const generateStylesheets = () =>
  fs
    .readdirSync('styles')
    .map(filename => {
      const symlink = distributionPath(filename);
      fs.existsSync(symlink) ||
        fs.symlinkSync(path.join('..', 'styles', filename), symlink);
      return `<link href="${filename}" rel="stylesheet">`;
    })
    .join('\n');

const main = () => {
  buildCovers();
  buildCovers(2);
  buildIndex();
};

const readInclude = name =>
  fs.readFileSync(path.join('includes', `${name}.html`), 'utf8');

const replaceTokens = (string, replacements) =>
  Object.entries(replacements).reduce(
    (string, [token, replacement]) =>
      string.replace(new RegExp(`\\{${token}}`, 'g'), replacement),
    string
  );

require.main === module && main();
