#!/usr/bin/env node
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const rollup = require('rollup');
const sources = require('./sources');
const {
  assert,
  cachePath,
  copyDirectory,
  copyFile,
  distributionPath,
  executeCommand,
  executeCurl,
  fetchURL,
  makeDirectories,
  memoize,
  symlinkFile,
} = require('.');

const coverScales = [1, 2];
const coverSize = 192;
const spriteHeight = 3;
const spriteWidth = 7;

const buildAllCovers = () => coverScales.forEach(scale => buildCovers(scale));

const buildCovers = scale => {
  const covers = distributionPath('covers');
  const outputMask = path.join(
    covers,
    `%d${scale === 1 ? '' : `@${scale}x`}.jpg`
  );
  scale === 1 || process.env.CI
    ? (fs.existsSync(outputMask.replace('%d', '0')) && !process.env.CI) ||
      executeCommand(
        [
          'montage',
          ...downloadCovers(),
          '-geometry',
          `${coverSize * scale}x${coverSize * scale}`,
          '-interlace',
          'Plane',
          '-quality',
          '80%',
          '-tile',
          `${spriteWidth}x${spriteHeight}`,
          makeDirectories(outputMask),
        ],
        { env: { MAGICK_TEMPORARY_PATH: cachePath() } }
      )
    : fs
        .readdirSync(covers)
        .filter(filename => !/@.+?x\.jpg$/.test(filename))
        .forEach(filename => {
          const output = outputMask.replace(
            '%d',
            path.basename(filename, '.jpg')
          );
          fs.existsSync(output) ||
            executeCommand([
              'convert',
              '-resize',
              `${scale * 100}%`,
              path.join(covers, filename),
              output,
            ]);
        });
  return fs
    .readdirSync(covers)
    .filter(filename =>
      new RegExp(
        path
          .basename(outputMask)
          .replace('%d', '\\d+')
          .replace('.', '\\.')
      ).test(filename)
    )
    .map(filename => path.join(covers, filename));
};

const buildIndex = () =>
  fs.writeFileSync(
    makeDirectories(distributionPath('index.html')),
    generateIndex()
  );

const cache = func => (...args) => {
  const cache = cachePath(
    `${func.name}:${crypto
      .createHash('md5')
      .update(JSON.stringify(args))
      .digest('hex')}`
  );
  fs.existsSync(cache) ||
    fs.writeFileSync(makeDirectories(cache), JSON.stringify(func(...args)));
  return JSON.parse(fs.readFileSync(cache, 'utf8'));
};

const copyImages = () => {
  const target = distributionPath('images');
  process.env.CI
    ? copyDirectory('images', target)
    : symlinkFile('../images', target);
};

const copyPDFJSFiles = () =>
  ['pdf.min.js', 'pdf.worker.min.js'].forEach(filename =>
    copyFile(
      path.join('node_modules/pdfjs-dist/build', filename),
      distributionPath('pdfjs', filename)
    )
  );

const downloadCovers = () => {
  const books = fetchBooks().map(book => ({
    ...book,
    cover: cachePath(book.source, `${book.slug}.jpg`),
  }));
  const options = books.reduce(
    (options, book) =>
      fs.existsSync(book.cover)
        ? options
        : [
            ...options,
            '-o',
            makeDirectories(book.cover),
            `https://data.booksie.org/${encodeURIComponent(
              book.source
            )}/${encodeURIComponent(book.slug)}.jpg`,
          ],
    []
  );
  options.length && executeCurl(options);
  return books.map(book => book.cover);
};

const fetchBooks = () =>
  JSON.parse(
    (process.env.CI ? memoize : cache)(fetchURL)(
      'https://data.booksie.org/books.json'
    )
  )
    .sort((a, b) => -a.added.localeCompare(b.added))
    .sort((a, b) => a.source.localeCompare(b.source));

const generateBook = book =>
  readInclude('book', {
    ...book,
    sourceName: assert(sources[book.source], `Unknow source ${book.source}`).name,
  });

const generateBooks = source => {
  const books = fetchBooks();
  let startIndex;
  return books
    .filter(book => book.source === source)
    .map((book, index) => {
      startIndex === undefined &&
        (startIndex = books.findIndex(
          foundBook =>
            foundBook.source === source && foundBook.slug === book.slug
        ));
      const absoluteIndex = startIndex + index;
      return {
        ...book,
        left: `${-(absoluteIndex % spriteWidth) * 100}%`,
        sprite: Math.floor(absoluteIndex / (spriteWidth * spriteHeight)),
        top: `${-Math.floor(absoluteIndex / spriteWidth) * 100}%`,
      };
    })
    .map(book => generateBook(book).trim())
    .join('');
};

const generateCoversStyle = () =>
  Array.from(
    Array(Math.ceil(fetchBooks().length / (spriteWidth * spriteHeight)))
  )
    .map((value, index) => {
      const imageURL = (scale = 1) =>
        `url(covers/${index}${scale === 1 ? '' : `@${scale}x`}.jpg)`;
      const images = coverScales.map(scale => `${imageURL(scale)} ${scale}x`);
      return `
.cover-${index}, html.scriptless .cover[data-cover="${index}"] {
  background-image: ${imageURL()};
  background-image: -webkit-image-set(${images.join(', ')});
  background-image: image-set(${images.join(', ')});
}
`.trim();
    })
    .join('\n');

const generateDevelopmentScript = () => {
  ['node_modules', 'scripts'].forEach(filename =>
    symlinkFile(path.join('..', filename), distributionPath(filename))
  );
  return `<script src="scripts/index.js" type="module"></script>`;
};

const generateDevelopmentStyle = () =>
  fs
    .readdirSync('styles')
    .map(filename => {
      symlinkFile(path.join('../styles', filename), distributionPath(filename));
      return `<link href="${filename}" rel="stylesheet">`;
    })
    .join('\n');

const generateFooter = () =>
  readInclude('footer', {
    script: process.env.CI
      ? generateProductionScript()
      : generateDevelopmentScript(),
    year: new Date().getFullYear(),
  }).trim();

const generateHead = () =>
  readInclude('head', {
    coverSize,
    coversStyle: generateCoversStyle(),
    description:
      'Booksie: an open catalog of free picture storybooks for children instantly available for reading.',
    name: 'Booksie',
    spriteHeight,
    spriteWidth,
    style: process.env.CI
      ? generateProductionStyle()
      : generateDevelopmentStyle(),
    title: 'Free Picture Storybooks for Children',
    url: `https://${fs
      .readFileSync('.travis.yml', 'utf8')
      .match(/(?<= fqdn: ).+/)}/`,
  }).replace('</html>\n', '');

const generateHeader = () => readInclude('header');

const generateIndex = () =>
  generateHead() + generateHeader() + generateMain() + generateFooter();

const generateMain = () =>
  readInclude('main', {
    books: generateSourceBooks(),
    sources: generateSources(),
    viewer: readInclude('viewer'),
  });

const generateProductionScript = () => `<script defer>
${executeCommand([
  'rollup',
  'scripts/index.js',
  '-f',
  'iife',
  '--silent',
]).trim()}
</script>`;

const generateProductionStyle = () =>
  `<style>
${fs
  .readdirSync('styles')
  .map(filename =>
    fs.readFileSync(path.join('styles', filename), 'utf8').trim()
  )
  .join('\n\n')}
</style>`;

const generateSourceBooks = () =>
  Object.keys(sources)
    .sort()
    .map(source =>
      readInclude('source-books', {
        ...sources[source],
        books: generateBooks(source),
        source,
      })
    )
    .join('\n');

const generateSources = () =>
  readInclude('sources', {
    links: Object.keys(sources)
      .sort()
      .map(source => `<a href="#${source}">${sources[source].name}</a>`)
      .join(', '),
  });

const main = () => {
  buildAllCovers();
  buildIndex();
  copyImages();
  copyPDFJSFiles();
};

const readInclude = (name, replacements = {}) =>
  replaceTokens(
    fs.readFileSync(path.join('includes', `${name}.html`), 'utf8'),
    replacements
  );

const replaceTokens = (string, replacements) =>
  Object.entries(replacements).reduce(
    (string, [token, replacement]) =>
      string
        .replace(new RegExp(`^ +(?=<!--${token}-->)`, 'gm'), '')
        .replace(new RegExp(`<!--${token}-->`, 'g'), replacement),
    string
  );

require.main === module && main();
